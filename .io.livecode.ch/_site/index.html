{% extends "base_livecode.html" %}

{% block title %}A Unified Approach to Solving Seven Programming Problems (Functional Pearl){% endblock %}

{% block content %}
<p>By William E. Byrd, Michael Ballantyne, Gregory Rosenblatt and Matthew Might.</p>
<p>To appear in ICFP 2017.</p>
<p>We present seven programming challenges in Racket, and an elegant, unified approach to solving them using constraint logic programming in miniKanren.</p>

<p>This pearl shows how a single unusual technique can solve a variety of programming problems.  Each problem is presented as a challenge to the reader, and we invite you to develop your own idea of how each problem might be solved before reading ours. If you'd like to consider the challenges with a frame of mind uncolored by our approach, feel free to jump ahead to Section 1. If you'd like a sneak peek, read on.</p>

<p>We solve each challenge by using an interpreter for a subset of Racket, or for a slight variant of Racket.  These interpreters are written as relations in the constraint logic programming language miniKanren. Each interpreter relates two arguments: an expression <code>expr</code> to be evaluated, and the value <code>val</code> to which <code>expr</code> evaluates.
These arguments may be only partially complete, containing logic variables representing unknown parts. Our miniKanren implementation will use constraint solving and search to fill in the logic variables with expressions and values consistent with the semantics of Racket.
By placing logic variables representing unknowns in different positions within the <code>expr</code> and <code>val</code> arguments we can express a wide range of interesting queries, which provides the flexibility needed to solve the variety of challenges we pose.</p>

<p>We also show that this technique works especially well for reasoning about programs written in a functional programming language such as Racket.</p>

<h3>A note about the problems.</h3>
<p>The problem in section <a href="#quines">2</a> is taken directly from Byrd et al. (2012), and the problem from section <a href="#i-love-you">1</a> is a simple variant of an example in that work.
We include these problems to provide background and understanding for the problems in sections <a href="#lexical-vs-dynamic">3</a> through <a href="#scheme-in-scheme">7</a>, which are all novel.<p>

<h2><a id="i-love-you"></a>99,000 ways to say (I love you) in Racket</h2>

<p>In his Valentine's Day blog post, "99 ways to say <code>'(I love you)</code> in Racket," one of the authors [<a href="http://matt.might.net/articles/i-love-you-in-racket/">Might 2013</a>] writes:

<blockquote>
In spite of their simplicity, lists often confound new Racket programmers.

After lists, the many forms for expressing a computation in Racket take time to discover and then master.

To address both of these points, I've created 99 roughly tweet-sized expressions in Racket that all evaluate to the list <code>'(I love you)</code>.
</blockquote>

<p class="footnote">Racket prints the list value <code>(I love you)</code> as the quotation expression <code>'(I love you)</code>, and Might follows this convention. In this paper we show just the value. To replicate our results in Racket, evaluate <code>(print-as-expression #f)</code> before the examples.</p>

<p>These examples, such as the three below, introduce students to an assortment of Racket's features.</p>

<div class="live" id="ex1">
(cdr '(Hark! I love you))</div>
<div class="live" id="ex2">
((lambda (a c b) (list a b c)) 'I 'you 'love)</div>
<div class="live norun" id="ex3">
(match #t
  [#f '(Not me)]
  [#t '(I love you)])</div>

<p>Inspired by a love of Racket, and a love of the list <code>(I love you)</code>, we want to go even further.</p>

<p><div class=challenge>
<b>Challenge 1.</b>
Come up with 99,000 Racket expressions that evaluate to the list <code>(I love you)</code>, demonstrating a variety of expression types in the spirit of the blog post.
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 1?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>We could follow Might's approach, and write the 99,000 Racket expressions by hand.

However, even we don't love the list <code>(I love you)</code> <em>that</em> much.

There must be a better way...<p>

<p>The semantics of a programming language can be defined by an evaluation relation, which relates programs to their behaviors.

For example, an evaluation relation for Racket relates the expression <code>(let ((x 5)) (+ x x))</code> with the value <code>10</code>.

An interpreter for Racket expressions is an implementation of the evaluation relation for a special case: the expression to be evaluated is known, and the value is to be derived.

What if instead of writing a normal interpreter, we implemented the evaluation relation in a constraint logic programming language, designed to query relations with any arguments unknown? We could solve our problem by simply leaving the expression argument as an unknown and specifying the value argument to be the list <code>(I love you)</code>.

To understand this approach we must first learn a little about how to write relations in <em>miniKanren</em>,
an embedded domain specific language for constraint logic programming [Byrd and Friedman 2006; Friedman et al. 2005].</p>

<h3><a id="relational-programming-in-minikanren"></a>Relational Programming in miniKanren</h3>

<p>Let's take list concatenation as our example. Here's how we might define <code>append</code> in Racket:</p>

<div class="live norun" id="append-1">
(define append
  (lambda (l s)
    (cond
      [(null? l) s]
      [else (cons (car l) (append (cdr l) s))])))
</div>

<p>We name results of intermediate expressions, in order to make our next transformation more clear.</p>

<div class="live norun" id="append-2">
(define append
  (lambda (l s)
    (cond
      [(null? l) s]
      [else
       (let* ((a (car l))
              (d (cdr l))
              (res (append d s)))
         (cons a res))])))
</div>

<p>This two-argument <code>append</code> function can now be translated into the three-argument \scheme{appendo} relation in miniKanren:</p>

<div class="live norun" id="appendo">
(define appendo
  (lambda (l s ls)
    (conde
      [(== '() l) (== s ls)]
      [(fresh (a d res)
         (== `(,a . ,d) l)
         (== `(,a . ,res) ls)
         (appendo d s res))])))
</div>

<p>We'll explain the miniKanren language forms used in this definition, but first let's take a look at what <code>appendo</code> can do.

The original <code>append</code> function can be used to concatenate two lists:

<div class="live" id="ex-append-1">
(append '(a b c) '(d e))
</div>

<p>The <code>appendo</code> relation can also be used the same way. In order to use the relation, we construct a <em>query</em> using the <code>run*</code> form. A query consists of <em>query variables</em> and calls to relations that will constrain those variables. Using search and constraint solving, miniKanren attempts to find values for the query variables that satisfy the constraints imposed by the relations. We emulate the behavior of <code>append</code> by calling <code>appendo</code> with concrete lists for the first two arguments, and the query variable <code>q</code> representing an unknown third argument:</p>

<div class="live" id="ex-appendo-1" data-lib="appendo">
(run* (q) (appendo '(a b c) '(d e) q))
</div>

<p>More excitingly, we can use <code>appendo</code> to <em>infer</em> the list <code>q</code> that, when prepended to the list <code>(d e)</code>, produces <code>(a b c d e)</code>:</p>

<div class="live" id="ex-appendo-2" data-lib="appendo">
(run* (q) (appendo q '(d e) '(a b c d e)))
</div>

<p class="footnote">These examples treating list concatenation as a relation will be familiar to any Prolog programmer.</p>

<p>A query needn't produce only a single answer. We can also infer all pairs of lists <code>x</code> and <code>y</code> that when appended together produce <code>(a b c d e)</code></p>

<div class="live" id="ex-appendo-3" data-lib="appendo">
(run* (x y) (appendo x y '(a b c d e)))
</div>

<p>Now that we've seen the added expressivity we get from writing <code>appendo</code> as a relation, let's consider its implementation. The definition of <code>appendo</code> uses the three core logical operators from miniKanren: <code>==</code>, <code>fresh</code>, and <code>conde</code>.  These operators construct goals representing logical assertions, which may succeed or fail.</p>

<p><code>(== t1 t2)</code> is a goal which asserts that <code>t1</code> and <code>t2</code> have the same value.

For example, <code>(== 5 5)</code> <em>succeeds</em>, while <code>(== 5 6)</code> <em>fails</em>.

<code>==</code> is implemented using <em>first-order unification</em>, essentially a bidirectional form of pattern matching.

Unification operates on <em>terms</em>.<a id="term-definition-paragraph"></a>

A  miniKanren term is either the empty list, a Boolean constant, a number, a symbol, a <em>logic variable</em>, or a pair of terms.

Logic variables start out <em>fresh</em>&mdash;that is, they initially have no value&mdash;and may later obtain a value through calls to <code>==</code>.

For example, assuming <code>x</code> is a fresh logic variable, <code>(== 5 x)</code> succeeds, and associates <code>x</code> with the value 5.

A subsequent call <code>(== 6 x)</code> would fail, since <code>x</code> would already be associated with 5.</p>

<p>As mentioned, we can apply <code>==</code> to terms that are pairs&mdash;for example, if <code>x</code> and <code>y</code> are fresh variables, the goal
<code>(== (cons 3 4) (cons x y))</code> would succeed, and associate <code>x</code> with <code>3</code> and <code>y</code> with <code>4</code>.

For succinctness we often write pairs and lists using Racket's <code>quasiquote</code> and <code>unquote</code> syntax.

The single characters <code>`</code> and <code>,</code> are shorthand for these forms, respectively.

All of these expressions are equivalent:</p>

<div class="live hidden" id="def-x">
(define x 5)
</div>

<div class="live" id="ex-cons-1" data-lib="def-x">
(cons 3 (cons (cons x (quote y)) (cons 4 (quote ()))))</div>
<div class="live" id="ex-cons-2" data-lib="def-x">
(list 3 (cons x (quote y)) 4)</div>
<div class="live" id="ex-cons-3" data-lib="def-x">
(list 3 (cons x 'y) 4)</div>
<div class="live" id="ex-cons-4" data-lib="def-x">
(quasiquote (3 ((unquote x) . y) 4))</div>
<div class="live" id="ex-cons-5" data-lib="def-x">
`(3 (,x . y) 4)</div>

<p>If the variable <code>x</code> were bound to <code>5</code>, each expression above would evaluate to <code>(3 (5 . y) 4)</code>.</p>

<p><code>(fresh (x* ...) g g* ...)</code> introduces lexically scoped, fresh logic variables <code>x* ...</code>; <code>fresh</code> also performs logical conjunction (`and') over the goals in its body, <code>g g* ...</code>, forming a new goal asserting that conjunction.

The <code>fresh</code> expression

<code>(fresh (y z) (== 5 y) (== 6 z) (== y z))</code>

first introduces logic variables <code>y</code> and <code>z</code>, then performs a conjunction of the three calls to <code>==</code>; <code>(== 5 y)</code> and <code>(== 6 z)</code> succeed, but <code>(== y z)</code> fails (since <code>y</code> and <code>z</code> are associated with <code>5</code> and <code>6</code>, which differ), causing the entire <code>fresh</code> expression to fail.</p>

<p><code>(conde (g0 g0* ...) (g1 g1* ...) ...)</code> constructs a goal that performs logical disjunction (`or') over its clauses.

Each clause acts as a conjunction over the goals it contains.

A simple <code>conde</code> expression is

<code>(conde ((== 3 x) (== 4 y)) ((== 5 x)))</code>

with the two clauses <code>((== 3 x) (== 4 y))</code> and <code>((== 5 x))</code>.

The first clause is a conjunction of \mbox{<code>(== 3 x)</code>} and \mbox{<code>(== 4 y)</code>}.

In this case both clauses succeed: the first clause associates <code>x</code> with <code>3</code> and <code>y</code> with <code>4</code>; the second clause produces a distinct answer that associates <code>x</code> with <code>5</code> but doesn't constrain <code>y</code>.

Since both clauses succeed, the entire <code>conde</code> expression succeeds twice, and can produce two answers.</p>

<p>Looking at the definition of <code>appendo</code>, we see its body is a <code>conde</code> expression with two clauses.  The first clause represents the base case, corresponding to the first clause of the <code>append</code> function's <code>cond</code> expression.  The goal <code>(== '() l)</code> corresponds to the <code>null?</code> check, while <code>(== s ls)</code> corresponds to returning the value of <code>s</code>, with <code>ls</code> representing the appended result of <code>l</code> and <code>s</code>.  The second clause corresponds to the second clause of the <code>append</code> function's <code>cond</code>.  Having named the intermediate results in <code>append</code>, we can see how the unifications in this clause correspond to taking the pair <code>l</code> apart, and constructing a return value using the result of a recursive invocation of <code>appendo</code>.  Because logical assertions can be made in any order, we are able to place the recursive invocation last in this clause.  This ordering is preferable, since encountering a failing unification early can make it unnecessary to perform the recursion.</p>

<p>Let's also revisit our query:</p>

<div class="live" id="ex-appendo-4" data-lib="appendo">
(run* (q) (appendo '(a b c) '(d e) q))
</div>

<p>Here <code>run*</code> introduces the query variable <code>q</code>, then evaluates its body as a conjunction of goals, returning a list of all the answers it produces.  Under the hood, miniKanren uses a search that traverses the tree of conjunctions and disjunctions constructed by <code>fresh</code> and <code>conde</code>.

Each answer consists of a list of values unified with query variables, followed by any additional side conditions introduced by lazy constraints.  In this case, there is only a single answer unifying a single query variable to a value that happens to be a list, resulting in a triply-nested list.  Here the single answer found unifies <code>q</code> with <code>(a b c d e)</code>. If we wanted miniKanren to stop searching after producing the first answer rather than continuing until it can prove there are no more, we could use \mbox{<code>run 1</code>} rather than <code>run*</code>.</p>

<h3><a id="a-relational-interpreter"></a>Loving Lists via a Relational Interpreter</h3>

<p>As we just saw, by treating list concatenation as a relation instead of a function we get additional, useful behavior.

This is also true of more complicated programs, such as interpreters.</p>

<p>Imagine an interpreter for a subset of Racket, written as a miniKanren relation.

This interpreter&mdash;which we might call <code>evalo</code>&mdash;would take two arguments: an expression <code>e</code> to be evaluated, and the value <code>v</code> of that expression.

For example,</p>

<div class="live hidden" id="evalo-standard">
(load "evalo-standard.scm")
</div>

<div class="live" id="ex-evalo-1" data-lib="evalo-standard">
(run 1 (q) (evalo '((lambda (x) x) 5) q))
</div>

<p>would return <code>((5))</code>, indicating the Racket expression
<code>((lambda (x) x) 5)</code> evaluates to the value <code>5</code>.</p>


<p>The good news is that <code>evalo</code> actually exists!  We've written an interpreter for a small&mdash;but interesting and Turing-complete&mdash;subset of Racket, including first-class multi-argument and variadic functions, <code>letrec</code> for defining recursive definitions, and a simple pattern matcher.</p>

<p class="footnote">Other than the pattern matcher, the language supported by <code>evalo</code> is also a subset of Scheme.</p>

<p>
Our <code>evalo</code> is inspired by, but significantly extends, the relational interpreter given in Byrd et al. (2012).

The even better news is that we can use <code>evalo</code> to generate expressions that evaluate to <code>(I love you)</code>!</p>



<p><div class=stopthink>
<b>Stop and think:</b>
Construct a miniKanren query that uses <code>evalo</code> to solve Challenge 1.
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>


<p>Let's start off small, by generating just a single expression that evaluates to <code>(I love you)</code>:</p>

<div class="live" id="ex-i-love-you-1" data-lib="evalo-standard">
(run 1 (q) (evalo q '(I love you)))
</div>

<p>Success!  The expression <code>'(I love you)</code> evaluates to the list <code>(I love you)</code>.  This expression isn't very exciting, though.  Let's try to find more interesting answers...

Emulating the blog post, we can replace <code>run 1</code> with <code>run 99</code>.</p>

<div class="live" id="ex-i-love-you-99" data-lib="evalo-standard">
(run 99 (q) (evalo q '(I love you))
</div>

Here are a few of the 99 expressions generated, all of which evaluate to <code>(I love you)</code>:

<div class="live" id="res-i-love-you-1">
(list 'I 'love 'you)</div>
<div class="live" id="res-i-love-you-2">
((lambda () '(I love you)))</div>
<div class="live" id="res-i-love-you-3">
(cons 'I '(love you))</div>
<div class="live" id="res-i-love-you-4">
(and '(I love you))</div>
<div class="live" id="res-i-love-you-5">
(car (list '(I love you)))</div>

<p>Here is a slightly more complex answer:</p>

<div class="live norun" id="res-i-love-you-6">
(((lambda _.0 _.0) 'I 'love 'you)
 (sym _.0))
</div>

<p>The <code>sym</code> side-condition tells us that <code>_.0</code> in the expression <code>((lambda _.0 _.0) 'I 'love 'you)</code> can be replaced by any legal Racket identifier (represented in our interpreter as a Racket symbol).

For example,</p>

<div class="live" id="res-i-love-you-7">
((lambda x x) 'I 'love 'you)</div>

<p>However, it's not actually necessary to replace <code>_.0</code> with another identifier, since <code>_.0</code> is itself a valid identifier in Racket:</p>

<div class="live" id="res-i-love-you-8">
((lambda _.0 _.0) 'I 'love 'you)</div>

<p>This answer is especially interesting because <code>(lambda x x)</code> is a <em>variadic</em> function&mdash;that is, a function that takes any number of arguments&mdash;which returns the arguments passed to it as a list.

The application <code>((lambda x x) 'I 'love 'you)</code> is equivalent to the expression <code>(list 'I 'love 'you)</code>.

Here is one more interesting answer:</p>

<div class="live norun" id="res-i-love-you-9">
((if _.0 '(I love you) _.1)
 (num _.0))
</div>

<p>The side condition <code>(num _.0)</code> indicates that <code>_.0</code> in the expression
<code>(if _.0 '(I love you) _.1)</code> represents an arbitrary numeric constant.

Replacing <code>_.0</code> with a specific number, such as <code>42</code>, yields the expression
<code>(if 42 '(I love you) _.1)</code>.

Since <code>42</code> is considered a true value in Racket, the `else' arm of the <code>if</code> expression is never evaluated.

Therefore <code>_.1</code> may be replaced by <em>any</em> legal Racket expression, and the overall expression will still evaluate to <code>(I love you)</code>.</p>

<p>There's something important happening in miniKanren's implementation to make these queries work. We can think of all the ways of constructing an expression as forming an infinite tree, branching at every point where a different kind of subexpression could be selected. The execution of the <code>evalo</code> relational interpreter searches through this tree for expressions that evaluate to <code>(I love you)</code>.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
Does it matter what search strategy miniKanren uses?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>In fact, the search strategy matters a great deal.<a id="search-bias-paragraph"></a> Searching an infinite tree requires care: for example, depth-first search could get stuck considering an infinite subtree that doesn't contain answers to our query. Even when depth-first search does find answers in an infinite tree, it might find only one kind of answer rather than the variety of answers we're looking for. Our example programs might then only use <code>list</code> and <code>car</code>, but never <code>lambda</code>. Thus it is important that miniKanren uses a complete search, which interleaves the processes of searching different parts of the tree [Kiselyov et al. 2005]. Our interleaving search also biases towards branches which have shown progress in the form of intermediate results, rewarding them with an increased share of the search effort. This bias allows miniKanren's search to investigate promising branches much more deeply than would unbiased complete searches like breadth-first and iterative deepening depth-first search.</p>

<p>Now it's time to shift our query into overdrive:</p>

<div class="live" id="ex-i-love-you-99000" data-lib="evalo-standard">
(run 99000 (q) (evalo q '(I love you)))
</div>

<p>Here are two artisanal, free-range <code>(I love you)</code> expressions, hand-curated from the 99,000 answers:

<div class="live" id="res-i-love-you-10">
((lambda ()
   (((lambda () cons)) 'I
    ((lambda _.0 '(love you)) list 42))))
</div>

<div class="live" id="res-i-love-you-11">
(car ((lambda (_.0) (_.0 '(I love you) 42 list)) list))
</div>

<p>Both answers include a <code>num</code> side-condition, which we've replaced with the number <code>42</code> so that the expressions will run without error in Racket.</p>

<h2><a id="quines"></a>Quines, twines, and thrines!  Oh my!</h2>

<p>In his classic paper, `A micro-manual for LISP &ndash; Not the whole
truth,' John McCarthy describes the rules for a LISP
evaluation function, <code>value</code>, and then offers this challenge [McCarthy 1978]:
<blockquote>
Difficult mathematical type exercise: Find a list e such that <code>value e = e</code>.
</blockquote>

<p><div class=challenge>
<b>Challenge 1.</b>
Solve McCarthy's exercise by finding a list <code>e</code> that evaluates to itself in Racket.
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 1?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>We could try to construct such a list by hand, either through trial-and-error or through cleverness.

If we were of a more theoretical bent, we could use Kleene's second recursion theorem [Kleene 1952] to construct <code>e</code>.</p>


<p>We adopt a different, more direct approach, originally presented by Byrd et al. (2012).

We can once again use <code>evalo</code>, the relational interpreter we describe in section <a href="#a-relational-interpreter">1.2</a>.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
Write a miniKanren query that uses <code>evalo</code> to find an expression <code>e</code> that evaluates to itself.
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>It's actually very simple to write such a query&mdash;just use the query variable as both the first and second arguments to <code>evalo</code> (representing the ``input'' expression and ``output'' value, respectively):</p>

<div class="live" id="ex-quine-1" data-lib="evalo-standard">
(run 1 (e) (evalo e e))
</div>

<p>And, indeed, this query produces an expression that evaluates to itself:</p>

<div class="live norun" id="res-quine-1">
(_.0 (num _.0))</div>

<p>This answer represents any expression <code>_.0</code> such that <code>_.0</code> is a number (represented by the <code>(num _.0)</code> side-condition).  That is, the answer represents <em>any</em> number.</p>

<p>
Expressions that evaluate to themselves have been named <em>quines</em> by Hofstadter [1979].

The single answer returned by our query represents <em>infinitely many</em> individual quines, since any numeric literal is trivially a quine in Racket&mdash;for example, the expression <code>42</code> evaluates to the value <code>42</code>.</p>

<div class="live" id="res-num">
42</div>

<p>We've found a trivial expression that evaluates to itself.

However, the actual challenge is to find a \emph{list} that evaluates to itself.

If we replace the <code>run 1</code> in our query with <code>run 3</code>, we get back two more trivial quines: <code>#t</code> and <code>#f</code>, the self-evaluating Boolean constants in Racket.</p>


<p>The fourth answer, produced with <code>run 4</code>, is more interesting:</p>

<div class="live norun" id="res-quine-4">
(((lambda (_.0) (list _.0 (list 'quote _.0)))
  '(lambda (_.0) (list _.0 (list 'quote _.0))))
 (=/= ((_.0 closure)) ((_.0 list)) ((_.0 prim)) ((_.0 quote)))
 (sym _.0))
</div>

<p>The first part of this answer is indeed a list that evaluates to itself:</p>

<div class="live" id="ex-quine-4">
((lambda (_.0) (list _.0 (list 'quote _.0)))
 '(lambda (_.0) (list _.0 (list 'quote _.0))))
</div>

<p><div class="aside">
<b>Fun fact:</b>
Though McCarthy describes finding quines as a ``difficult mathematical type exercise,'' the quine-generating query is the <em>simplest</em> possible query involving <code>evalo</code>, in that it contains the minimal number of distinct symbols.
</div></p>

<p>The side-conditions in the second part of the answer tell us that <code>_.0</code> can be any legal Racket identifier, other than <code>closure</code>, <code>list</code>, <code>prim</code>, or <em>quote</em>.

For example, we could replace <code>_.0</code> with the identifier <code>x</code>:</p>

<div class="live" id="ex-quine-4-x">
((lambda (x) (list x (list 'quote x)))
 '(lambda (x) (list x (list 'quote x))))
</div>

<p>However, it would not be legal to replace <code>_.0</code> with the identifier <code>list</code>, since this would shadow the <code>list</code> function used in the body of the <code>lambda</code> expression:</p>

<div class="live" id="ex-quine-4-list">
((lambda (list) (list list (list 'quote list)))
 '(lambda (list) (list list (list 'quote list))))
</div>

<p>Internally <code>evalo</code> uses <code>closure</code> and <code>prim</code> as datatype tags, which is why these names cannot be used in expressions.  This leaky abstraction could be mitigated by generating unique symbols for these tags.  To truly plug up the leak, we would also have to tag all pairs, which would permit the unambiguous use of these tags as values.</p>

<p>We can produce our non-trivial quine using <code>run 1</code> rather than a <code>run 4</code>
if we unify <code>e</code> with the pair <code>`(,a . ,d)</code>, forcing <code>e</code> to be a list:</p>

<div class="live" id="ex-quine-1-list" data-lib="evalo-standard">
(run 1 (e)
  (fresh (a d)
    (== `(,a . ,d) e))
  (evalo e e))
</div>

<p>We can also use <code>evalo</code> to generate <em>twines</em>&mdash;two distinct expressions <code>p</code> and <code>q</code> such that <code>p</code> evaluates to <code>q</code> and <code>q</code> evaluates to <code>p</code>:</p>

<div class="live" id="ex-twines-1" data-lib="evalo-standard">
(run 1 (p q)
  (=/= p q)
  (evalo p q)
  (evalo q p))
</div>

<p>Our query uses the <em>disequality constraint</em> operator <code>=/=</code> to assert that <code>p</code> and <code>q</code> must be different.</p>

<p>The result of the query indicates <code>p</code> is the expression</p>

<div class="live" id="res-twines-1-p">
'((lambda (_.0) (list 'quote (list _.0 (list 'quote _.0))))
  '(lambda (_.0) (list 'quote (list _.0 (list 'quote _.0)))))
</div>

<p>and <code>q</code> is the expression</p>

<div class="live" id="res-twines-1-q">
((lambda (_.0) (list 'quote (list _.0 (list 'quote _.0))))
 '(lambda (_.0) (list 'quote (list _.0 (list 'quote _.0)))))
</div>

<p>where, once again, <code>_.0</code> can be any legal Racket identifier, other than <code>closure</code>, <code>list</code>, <code>prim</code>, or <em>quote</em>.  Importantly, <code>_.0</code> must have the same value in both <code>p</code> and <code>q</code>.<p>

<p><div class="insight">
<b>Insight:</b>
  ``Lazy constraints''&mdash;such as the disequality constraint <code>=/=</code> and the <code>numbero</code> constraint used to construct the <code>num</code> side-condition&mdash;are an important part of constraint logic programming [Jaffar and Lassez 1987] that we take advantage of here.  These constraints are critical to the performance of <code>evalo</code>.

The abstract representation of a number allowed by the <code>numbero</code> constraint prevents the quine-generating query from enumerating infinitely many trivial quines.

Disequality constraints provide an important form of negation.

Using unification alone, disequality between terms must be expressed by enumerating all possible combinations of values that differ, making twine generation hopelessly inefficient.
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
Write a query that generates a <code>thrine</code>---that is, three distinct expressions <code>p</code>, <code>q</code>, and <code>r</code> such that <code>p</code> evaluates to <code>q</code>, <code>q</code> evaluates to <code>r</code>, and <code>r</code> evaluates to <code>p</code>.
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>Here is the thrine-generating query, which requires a disequality constraint for each pairing of <code>p</code>, <code>q</code>, and <code>r</code>:</p>

<div class="live" id="ex-thrines-1" data-lib="evalo-standard">
(run 1 (p q r)
  (=/= p q)
  (=/= p r)
  (=/= q r)
  (evalo p q)
  (evalo q r)
  (evalo r p))
</div>

<p>Chaining additional uses of <code>evalo</code>, going from quines to twines to thrines, results in the query taking more time and memory.

The thrines-generating query may not find a thrine before running out of memory, unless some of the primitives and forms are removed from the <code>evalo</code> relation, which reduces the branching factor of the search.</p>

<h2><a id="lexical-vs-dynamic"></a>Lexical vs. dynamic scope</h2>

<p><div class=challenge>
<b>Challenge 3.</b>
Many students struggle with the concept of lexical scope versus dynamic scope.

To help these students out, generate 100 expressions that evaluate to 42 under lexical scope, and 137 under dynamic scope.

To help focus on issues of scope, use a restricted subset of Racket that corresponds to the call-by-value &lambda;-calculus extended with numeric constants.
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 3?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>We've seen that we can synthesize programs that evaluate to a particular value&mdash;such as <code>(I love you)</code>&mdash;using a relational interpreter. Our solution to this challenge evaluates an unknown expression simultaneously in <em>two</em> relational interpreters: one implementing lexical scope and one implementing dynamic scope.</p>

<p>We need only a few language forms to reveal distinctions between the two scoping disciplines: lambda, variable reference, function application, and numeric literals for the return values specified in the challenge.
<!--Figure~\ref{fig:interp} shows the big-step operational semantics for the lexically-scoped version of this minimal language, along with the corresponding relational interpreter in miniKanren.-->
</p>

<!--In the semantics, $\rho \vdash e \Rightarrow v$ means the expression $e$ evaluates to the value $v$ in the environment $\rho$.
%
The metavariable $n$ represents any number, $v$ any value (which includes numbers and closures), $x$ any identifier, $e$ any expression, and $\rho$ any environment (a mapping from identifiers to values).-->

<p>The evaluation judgement is implemented as the miniKanren relation <code>eval-expr-lexo</code>. In our queries we'll use the relation <code>eval-lexo</code> which just calls <code>eval-expr-lexo</code> with the empty environment.

We point out the interesting features of the miniKanren code corresponding to each inference rule:</p>

<ul>
    <li> <b>const</b> The lazy <code>numbero</code> constraint ensures the clause only applies when <code>expr</code> is a number.</li>

    <li> <b>abs</b> Shadowing is allowed, so the rule only applies when <code>lambda</code> isn't bound in the environment. The recursive <code>not-in-envo</code> relation implements this restriction. Because miniKanren uses first-order unification, we must use data structural representations of expressions, environments, and closures. Expressions are represented as s-expressions, environments as association lists, and closures as lists containing the symbol <code>'closure</code>, the code for the procedure, and the environment where the lambda was evaluated.</li>

    <li> <b>ref</b> The recursive <code>lookupo</code> relation implements variable lookup in the environment (represented as an association list). The lazy <code>symbolo</code> constraint asserts that the expression is a symbol representing a lexical variable.</li>

    <li> <b>app</b> The <code>ext-envo</code> relation extends the environment by unifying <code>new-env</code> with <code>`((,x . ,val) . ,cenv)</code>.</li>
</ul>

<p><div class="insight">
<b>Insight:</b>
    These semantics don't exactly correspond to a subset of Racket. We only care about the behavior of programs that terminate and don't produce errors. As such, we can cheat a little and get away with it! For example, our interpreter won't evaluate the remaining expressions in an application if the first expression, the operator, doesn't evaluate to a closure. In Racket, <code>(5 ((lambda (x) (x x)) (lambda (x) (x x))))</code> loops infinitely, but its evaluation in <code>eval-lexo</code> terminates with failure. Even better, our optimization makes the evaluation of the application <code>(5 e)</code>, where <code>e</code> is an unknown expression, terminate with failure as well. Without this optimization, miniKanren would have to generate, and evaluate, each of the infinitely many possible expressions <code>e</code>.

    Our ``cheat'' to optimize application is valid because our interpreter implements a purely functional language.  Any successful, terminating evaluation must eventually check that the value of the operator expression is a closure. What might happen if we applied this optimization to an interpreter for a language with exceptions? For a language with user-defined exceptions that can be thrown, but not caught, we might treat throwing an exception as failure. Our optimization would remain correct. However, we might instead write an interpreter for a language where exceptions can be caught, or where we want to report details of the exception rather than fail. Then the interpreter must apply the optimization only when it is guaranteed that evaluation will eventually check that the value of the operator expression is a closure. First-class control operators like <code>call/cc</code> present a similar challenge.
</div></p>

<p>Creating a variant of the interpreter for dynamic scope requires only a tiny change to the application rule: rather than extending <code>cenv</code>, the environment from the closure, we extend <code>env</code>, the environment at the call site. We'll refer to this variant as <code>eval-dyno</code>.</p>

We're ready to solve the challenge! Our query applies each of the two interpreters to the same unknown expression <code>expr</code>, asserting that in each interpreter <code>expr</code> evaluates to the right number.

<div class="live hidden" id="evalo-scoping">
(load "evalo-scoping.scm")
</div>

<div class="live" id="run-expr-1" data-lib="evalo-scoping">
(run 1 (expr)
  (eval-dyno expr 137)
  (eval-lexo expr 42))
</div>

<p>We can easily ask for many more programs; a <code>run 100</code> query finds 100 in 1.7 seconds on an early 2013 MacBook Pro.</p>

<p>Curiously, the query is very slow if the <code>eval-dyno</code> call is reordered after the <code>eval-lexo</code> call.

It turns out that this reordered query spends most of its time evaluating non-terminating programs!

Relatively simple programs in the language of <code>eval-dyno</code> can express non-terminating computations; some of these programs may terminate in <code>eval-lexo</code>. For example, here's a program that evaluates to 42 under lexical scope but does not terminate under dynamic scope:</p>
<div class="live" id="ex-scoping-1">
((lambda (x)
   ((lambda (x) (x 1))
    (lambda (y) (x 2))))
 (lambda (z)
   42))
</div>

<p><div class=stopthink>
<b>Stop and think:</b>
    Why does the evaluation of this expression never terminate with dynamic scope?
</div></p>

<p>After the outermost function application, the subexpression</p>
<div class="live" id="ex-scoping-2">
((lambda (x) (x 1))
 (lambda (y) (x 2)))
</div>
<p>is evaluated. The parameter of the first <code>lambda</code> expression binds <code>x</code> to the procedure resulting from the second <code>lambda</code> expression. The body of that procedure, <code>(x 2)</code>, is evaluated while the binding is still present in the dynamic environment, making it a recursive call.</p>

<p>Program synthesis tools generally need to take special care to avoid non-terminating programs, and sometimes employ termination checking to rule them out. How is it that our relational interpreters don't get totally stuck when evaluating a non-terminating program?</p>

<p>Instead of exploring the alternative solutions represented by different <code>conde</code> clauses in sequence, the miniKanren search interleaves the work. A non-terminating computation in one clause will consume computational effort but cannot entirely halt work on other solutions. Even with an interleaving search strategy, however, we can still get in trouble. If many non-terminating computations stack up, they can starve work on other candidate solutions for resources. In many circumstances our search is clever enough to avoid that possibility, but here it fails.</p>

<p>In the reordered query with <code>eval-lexo</code> first, the search quickly finds many partial programs that evaluate to 42 in lexical scope. Each of these programs are subsequently evaluated under dynamic scope, and as in the example above, some will never terminate. The implementation of conjunction in miniKanren assigns half of the computational effort to evaluating the first lexical scope solution under dynamic scope, a quarter to the second, an eighth to the third, and so on. That strategy works well when each evaluation quickly succeeds or fails. When those computations fail to terminate, however, later solutions are starved for time.</p>

<p>Why does the query work better with <code>eval-dyno</code> first? Our <code>eval-lexo</code> language doesn't provide a form like <code>letrec</code> for direct recursion, so non-terminating programs require a more complex construction like the Z-combinator (the call-by-value Y-combinator). As a result, the programs that <code>eval-dyno</code> finds before solving our query happen to terminate in <code>eval-lexo</code>.</p>

<h2><a id="append"></a>Relationality for free</h2>

<p><div class=challenge>
<b>Challenge 4.</b>
We've seen the flexibility of the <code>appendo</code> relation in section <a href="#relational-programming-in-minikanren">1.1</a>.  Is there a way to get the same flexibility, but using the standard Racket definition of the <code>append</code> function?
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 4?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>One solution to this problem would be a Racket-to-miniKanren compiler, or a macro with the same functionality.

However, if <code>evalo</code> implements enough of Racket to run <code>append</code>, we can solve this problem directly: we just run the Racket definition of <code>append</code> inside a query to <code>evalo</code>.</p>

<p>To keep the implementation of <code>evalo</code> simple, we define <code>append</code> using <code>letrec</code> instead of <code>define</code>, and using <code>if</code> instead of <code>cond</code>.

Naturally we can run <code>append</code> forwards:</p>

<div class="live" id="ev-appendo-1" data-lib="evalo-standard">
(run 1 (q)
  (evalo
    `(letrec ([append (lambda (l s)
                        (if (null? l)
                            s
                            (cons (car l) (append (cdr l) s))))])
       (append '(a b c) '(d e)))
    q))
</div>

<p>Remember how we used <code>appendo</code> as a relation in section <a href="#relational-programming-in-minikanren">1.1</a>:
<div class="live" id="ex-appendo-star" data-lib="appendo">
(run* (q) (appendo q '(d e) '(a b c d e)))
</div>

<p>Because <code>run*</code> returned a single answer, miniKanren has proven that no other answers exist: only <code>(a b c)</code> can be prepended to <code>(d e)</code> to produce <code>(a b c d e)</code>.</p>

<p>The <code>appendo</code> relation has three arguments, with the last one representing the result of appending the first two arguments. When evaluating a call to <code>append</code> in the relational interpreter, the second argument to <code>evalo</code> serves a similar purpose, representing the return value of the <code>append</code> function.</p>

<p>This means we can use <code>append</code> as a relation! We pass the logic variable <code>q</code> as the first argument to <code>append</code>, using <code>unquote</code> <code>,</code> to escape the <code>quasiquote</code> <code>`</code> form wrapping the <code>letrec</code>.</p>

<div class="live" id="ev-appendo-2" data-lib="evalo-standard">
(run 1 (q)
  (evalo
    `(letrec ([append (lambda (l s)
                        (if (null? l)
                            s
                            (cons (car l) (append (cdr l) s))))])
       (append ,q '(d e)))
    '(a b c d e)))
</div>

<p>It seems to work. Let's try the same query with <code>run*</code> to see whether evaluating <code>append</code> in the interpreter can replicate <code>appendo</code>'s ability to prove that only one answer exists.</p>

<p>Alas, we'll be waiting a long time indeed; the <code>run*</code> query never returns a result. There are two possible causes: either there are infinitely many answers, or there are finitely many but miniKanren can't prove this. If there are many answers, a <code>run 2</code> query should terminate with two answers. If there is only the one answer, the <code>run 2</code> query should loop forever just like the <code>run*</code> query.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
Will the <code>run 2</code> query return two answers, or will it loop forever?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p><code>run 2</code> actually terminates with these two answers:</p>
<div class="live norun" id="app-ans">
(('(a b c))
 (((lambda _.0 '(a b c))) (=/= ((_.0 quote))) (sym _.0)))
</div>
<p>What's <code>lambda</code> doing there?</p>

<p>Whereas <code>appendo</code> operates on lists, the relational interpreter operates on expressions. The first argument to <code>append</code> can be any of an infinite class of expressions that evaluate to the list <code>(a b c)</code>! And one such expression is <code>((lambda _.0 '(a b c)))</code>.

The fact that we're synthesizing expressions rather than values also explains a subtle change you may have noticed in the first answer: the query finds the quotation expression <code>'(a b c)</code> rather than the value <code>(a b c)</code>.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
How can we recover the behavior of <code>appendo</code>, where <code>run*</code> proves there is only one list <code>q</code> that when prepended to <code>(d e)</code> produces <code>(a b c d e)</code>?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>The smallest of changes will do: just add a quote before the unquoted logic variable <code>q</code>. For each value, there is only one quotation expression that evaluates to that value.</p>
<div class="live" id="ev-appendo-3" data-lib="evalo-standard">
(run* (q)
  (evalo
    `(letrec ([append (lambda (l s)
                        (if (null? l)
                            s
                            (cons (car l) (append (cdr l) s))))])
       (append ',q '(d e)))
    '(a b c d e)))
</div>

<p>We've found that <code>append</code> in the relational interpreter has all the power of the <code>appendo</code> relation implemented in miniKanren.

Even better, the relational behavior of <code>append</code> and the interpreter's ability to generate expressions combine; we can now query for Racket expressions whose values satisfy a given call to <code>append</code>.</p>


Let's go even further. Not only can we generate expressions in argument position of the call to <code>append</code>, we can generate expressions for the implementation of <code>append</code>. We can even run the (as yet partially unknown) <code>append</code> function backwards.  We can do all of these things in a single query:</p>
<div class="live" id="ev-appendo-4" data-lib="evalo-standard">
(run 1 (x y)
  (evalo
    `(letrec ([append (lambda (l s)
                        (if (null? l)
                            s
                            ;; We use ,x here to leave part of the definition unknown.
                            (cons ,x (append (cdr l) s))))])
       (list (append ,y '(c d e)) (append '(f g h) '(i j))))
    '((a b c d e) (f g h i j))))
</div>

<p>Let's discuss how this program is represented as a miniKanren term so that we can explain what is happening.

A term can be either <em>fully instantiated</em> (containing no logic variables), <em>partially instantiated</em> (having some fixed structure, but containing one or more logic variables), or <em>fully uninstantiated</em> (a single logic variable with no associated value).

In this case we've left part of the definition of <code>append</code> uninstantiated, representing the missing code with the logic variable <code>x</code>.</p>

<p>The program calls <code>append</code> twice: once with the output fully instantiated but part of the input unknown, represented by the logic variable <code>y</code>, and once with fully instantiated input and output.

As the relational interpreter evaluates the first call to <code>append</code>, it synthesizes assignments of <code>x</code> and <code>y</code> such that <code>(append y '(c d e))</code> evaluates to <code>(a b c d e)</code>.

The second call selects from those assignments a solution with an <code>x</code> such that <code>(append '(f g h) '(i j)))</code> evaluates to <code>(f g h i j)</code>.

The query instantiates <code>x</code> to the correct code snippet <code>(car l)</code>, and <code>y</code> to the correct missing argument, <code>'(a b)</code>.

This query <em>simultaneously</em> performs code synthesis and bidirectional evaluation.</p>

<p>At this point, it's natural to wonder how much of <code>append</code> can be synthesized with this technique.  With a straightforward, unoptimized implementation of <code>evalo</code>, only small parts of <code>append</code> can be synthesized in a reasonable amount of time.  Can we do better?  By optimizing a few key portions of <code>evalo</code>, we can in fact synthesize the entire body of <code>append</code> from just a few examples of its use!  We'll briefly describe the optimizations that enable this degree of synthesis, but these details aren't necessary for an understanding of the rest of the paper.</p>

<p>The most significant optimization we implement orders goals carefully when performing procedure application.  We evaluate the operator expression first to determine whether its value is a closure.  If it's a closure, we next evaluate operand expressions that are at least partially instantiated, followed by the closure body, and then finally the fully uninstantiated operand expressions.</p>

<p>This order best takes advantage of known information. Evaluating partially instantiated operand expressions is assumed to be straightforward, and doing this first means that the values of corresponding variable references in the closure body do not need to be guessed blindly. Evaluating the closure's body before evaluating uninstantiated operand expressions reduces the number of branching computations between guessing and testing: guesses about the body can be immediately tested against the expected result of the application, whereas uninstantiated operand expressions cannot be immediately tested.</p>

<p>Consider this query:</p>
<div class="live" id="ev-taglet-1" data-lib="evalo-standard">
(run 1 (e)
  (evalo
    `(taglet ((x 7))
       ((lambda (a d)
          (cons a d))
        ,e x))
    '(5 . 6)))
</div>

<p>Within the body of the <code>let</code> we would first evaluate the <code>lambda</code> expression to a closure, then <code>x</code> to <code>7</code>, followed by the closure body <code>(cons a d)</code> where <code>d</code> is bound to <code>7</code> and <code>a</code> is still unknown. Only if those succeed would we start guessing terms for <code>e</code>.  In this case the query fails before we make any guesses. Evaluating the closure body produces a pair whose <code>cdr</code> is <code>7</code>, which cannot possibly fit our expected result of \schemeresult|(5 . 6)|, whose <code>cdr</code> is <code>6</code>.</p>

<p>Because we are implementing a purely functional language, we can perform these reorderings without changing a program's behavior.  If evaluating <code>e</code> could produce side effects, such as mutating the value of <code>x</code>, we would have to be more careful.</p>

<p>Here are some other optimizations that help a great deal:</p>

<ul>
    <li>To reduce uninformed guessing when encountering branches, we defer invoking the goals constructed by some uses of <code>conde</code> when it seems likely that more than one clause will succeed.  Deferred goals are queued up to be retried later, after all informed guesses have been made, with the hope of having learned more useful information by the time we retry.</li>

    <li>Though we continue to support a complete search, we first try a depth-limited search, which prunes search branches that get very deep.  These branches are often unpromising.  If no answers are found, we fall back on the unlimited, complete search. The bias in our search described on page~\pageref{search-bias-paragraph} is also important for the remaining challenges; a simple iterative deepening search won't work.</li>

    <li>To greatly reduce the expense of searching for useful conditional expressions, we restrict conditions to expressions that evaluate to Boolean constants <code>#t</code> and <code>#f</code> (as opposed to other ``true'' Racket values, such as `<code>5</code>').</li>

    <li>We also perform some other minor optimizations, such as hand-tweaking the weighting of some <code>conde</code> clauses in <code>evalo</code>, favoring expression types that are more common.</li>
</ul>

<p>Let's get back to synthesizing <code>append</code>.  We'll start by providing a couple of example calls.</p>

<div class="live" id="syn-app-1" data-lib="evalo-standard">
(run 1 (defn)
  (fresh (body)
    (== defn `(append (lambda (xs ys) ,body)))
    (evalo
      `(letrec (,defn)
         (list (append '() '())
               (append '(1) '(2))))
      '(() (1 2)))))
</div>

<p>This definition doesn't look right.  Although it supports our specific query, it isn't general enough to append arbitrary lists.  What went wrong?</p>

<p>Because the search simply looks for any definition that works, a simple way to satisfy the constraints is to simply return our example output verbatim.  This is why we see our expected second result embedded directly in the definition.  How do we get around this?</p>

<p>One solution is to prohibit the definition from mentioning our example data directly.  The constraint \mbox{<code>(absento t1 t2)</code>} prevents term <code>t1</code> from appearing anywhere in term <code>t2</code>.</p>

<p class="footnote">The miniKanren implementation we use for this pearl restricts <code>t1</code> to be a literal symbol or number rather than a term. Other implementations can handle the general version of the constraint.</p>

<p>We can use <code>absento</code> to prevent numbers from our examples from appearing in the definition we're synthesizing.  We provide an <code>absento</code> constraint for each number we mention.</p>

<div class="live" id="syn-app-2" data-lib="evalo-standard">
(run 1 (defn)
  (fresh (body)
    (absento 1 defn) (absento 2 defn)
    (== defn `(append (lambda (xs ys) ,body)))
    (evalo
      `(letrec (,defn)
         (list (append '() '())
               (append '(1) '(2))))
      '(() (1 2)))))
</div>

<p>Though our example result is no longer embedded in the definition, the definition still is not general enough to append arbitrary lists.  It handles exactly the cases of the empty and single element lists.  The definition can't handle larger lists because it's not recursive!</p>

<p><div class=stopthink>
<b>Stop and think:</b>
How can we synthesize a more general version of <code>append</code>?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>Adding a couple more usage examples helps us find a more general definition.</p>

<div class="live" id="syn-app-3" data-lib="evalo-standard">
(run 1 (defn)
  (fresh (body)
    (absento 1 defn) (absento 2 defn) (absento 3 defn) (absento 4 defn)
    (== defn `(append (lambda (xs ys) ,body)))
    (evalo
      `(letrec (,defn)
         (list (append '() '())
               (append '(1) '())
               (append '(1) '(2))
               (append '(1 2) '(3 4))))
      '(() (1) (1 2) (1 2 3 4)))))
</div>

<p>This query responds with a fully general definition of <code>append</code>, implemented as a recursive procedure.

Why isn't the answer, once again, specific to exactly the examples provided?

Given enough examples, the simplicity of the recursive solution makes it easier to find than the overly-specific solution!</p>

<p>Though we can synthesize <code>append</code> from scratch, what if a standard library were available?  Would we be able to define <code>append</code> in terms of existing definitions?  Let's try providing <code>fold-right</code>.</p>

<div class="live" id="syn-app-4" data-lib="evalo-standard">
(run 1 (defn)
  (fresh (body)
    (absento 1 defn) (absento 2 defn) (absento 3 defn) (absento 4 defn)
    (== defn `(append (lambda (xs ys) ,body)))
    (evalo
      `(letrec ((fold-right (lambda (f acc xs)
                              (if (null? xs) acc
                                  (f (car xs) (fold-right f acc (cdr xs))))))
                ,defn)
         (list (append '() '())
               (append '(1) '())
               (append '(1) '(2))
               (append '(1 2) '(3 4))))
      '(() (1) (1 2) (1 2 3 4)))))
</div>

<p>With <code>fold-right</code> available in the environment, <code>append</code> is quickly defined in terms of it!</p>

<p>While our optimized relational interpreter can both synthesize recursive functions and take advantage of higher-order functions, it struggles with larger programs. The search space grows exponentially with the size of the smallest correct definition of the program to be synthesized. Our current implementation can't synthesize complete recursive programs much larger than <code>append</code>.</p>

<h2><a id="refutation"></a>Taking Test-Driven Development Seriously</h2>

<p>Test-driven development asks us to write our test cases before we write our programs, so that we can receive immediate feedback on the code we've written.

Say we're writing a program <code>remove</code> that removes all occurrences of a symbol <code>x</code> that occur as top-level elements in a list <code>ls</code>.

Our first job is to describe <code>remove</code> with a set of tests:</p>

<div class="live" id="ex-remove-1">
(list (remove 'foo '())
      (remove 'foo '(foo))
      (remove 'foo '(1))
      (remove 'foo '(2 foo 3))
      (remove 'foo '((4 foo) foo (5 (foo 6 foo)) foo 7 foo (8))))
</div>

<p>Let's pretend that after thinking over the cases that our function must handle, we have written the program skeleton below.  Here <code>A</code>, <code>B</code>, and <code>C</code> represent ``holes,'' which are expressions we've yet to fill in.</p>
<div class="live norun" id="def-remove-1">
(define remove
  (lambda (x ls)
    (cond
      [(null? ls) '()]
      [(equal? (car ls) x) (cons A B)]
      .
      C)))
</div>

<p>We've already made a mistake! Though the program isn't complete, there is no way to fill in the holes to form a definition of <code>remove</code> that matches our tests.

Sadly, test-driven development in a typical programming environment doesn't help us: we can't run tests on an incomplete program.</p>

<p><div class=challenge>
<b>Challenge 5.</b>
How can we determine that we've already made a mistake?
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 5?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>Using our relational interpreter we actually <em>can</em> run the test suite with our incomplete program, by representing any holes with (unquoted) logic variables.
<div class="live hidden" id="evalo-optimized-f">
(load "evalo-optimized.scm")
(set! allow-incomplete-search? #f)
</div>
<div class="live" id="run-remove-1" data-lib="evalo-optimized-f">
(run 1 (A B C)
  (evalo
    `(letrec ([remove (lambda (x ls)
                        (cond
                          [(null? ls) '()]
                          [(equal? (car ls) x) (cons ,A ,B)]
                          .
                          ,C)) ])
       (list (remove 'foo '())
             (remove 'foo '(foo))
             (remove 'foo '(1))
             (remove 'foo '(2 foo 3))
             (remove 'foo '((4 foo) foo (5 (foo 6 foo)) foo 7 foo (8)))))
    '(() () (1) (2 3) ((4 foo) (5 (foo 6 foo)) 7 (8)))))
</div>

<p>Our query responds almost immediately with the empty answer set.  Because miniKanren uses a complete search that is guaranteed to find an answer if one exists, the empty answer set means there is no correct way to synthesize expressions to fill in the holes.  We've proved that an incomplete program is inconsistent with its test cases!  We call such a proof a <em>refutation</em> of the program.</p>

<p>It's worth pausing for a moment to discuss how refutation works, and how it can be so fast.  We mentioned that the underlying system runs a complete search, and it may be tempting to assume the search uses blind, brute force.  But this search isn't blind.  By working top-down, connecting expected result values to the outer expression shapes being considered, the search can prune unpromising branches very early on.  It's only after the outer expression shape is shown to be compatible with the desired result that sub-expressions are considered.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
We know our program is wrong.  How do we figure out <em>where</em> it went wrong?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>By attempting to satisfy tests individually, we can get a hint at the problem.</p>

<p class="footnote">In general, all test subsets may need to be checked since a subset may fail even if all its tests are individually satisfiable.</p>

<p>In this case, the only unsatisfiable test is:</p>

<p><code>(remove 'foo '(foo)) => ()</code></p>

<p>This failing test suggests <code>remove</code> does not work correctly when the first list element is the item to be removed.  If we relax a portion of our program by forming more or larger expression holes, looking for the moment our test becomes satisfiable, we can narrow down the problem.  In this case, we are able to satisfy our query by relaxing the right-hand-side expression of our equality clause.</p>

<div class="live" id="run-remove-2" data-lib="evalo-optimized-f">
(run 1 (A B C)
  (evalo
    `(letrec ([remove (lambda (x ls)
                        (cond
                          [(null? ls) '()]
                          [(equal? (car ls) x) ,A]
                          .
                          ,C)) ])
       (remove 'foo '(foo)))
    '()))
</div>

<p>The test now passes, suggesting it was a mistake to try <code>(cons ,A ,B)</code> in the equality clause;
the clause should produce the empty list, not a pair.  With this insight, we can continue implementing <code>remove</code>.</p>

<p>Let's try the related problem of removing a symbol from anywhere in an s-expression, even inside deeply nested lists.  Our test suite should return slightly different answers:</p>

<div class="live" id="ex-remove-2">
(list (remove 'foo '())
      (remove 'foo '(foo))
      (remove 'foo '(1))
      (remove 'foo '(2 foo 3))
      (remove 'foo '((4 foo) foo (5 (foo 6 foo)) foo 7 foo (8))))
</div>

<p>Using <code>evalo</code> to run our program as we write it, we notice a refutation:</p>
<div class="live" id="run-remove-3" data-lib="evalo-optimized-f">
(run 1 (A B)
  (evalo
    `(letrec ([remove (lambda (x ls)
                        (cond
                          [(null? ls) '()]
                          [(equal? (car ls) x) ,A]
                          [else (cons (car ls) ,B)]))])
       (list (remove 'foo '())
             (remove 'foo '(foo))
             (remove 'foo '(1))
             (remove 'foo '(2 foo 3))
             (remove 'foo '((4 foo) foo (5 (foo 6 foo)) foo 7 foo (8)))))
    '(() () (1) (2 3) ((4) (5 (6)) 7 (8)))))
</div>

<p>Checking each test individually, we learn that our last test case is unsatisfiable.</p>

<p>Relaxing expressions that contain logic variables suggests a problem with the right-hand-side of our <code>else</code> clause. Using <code>(cons (car ls) ,B)</code> causes the last test to fail, while <code>(cons ,C ,B)</code> does not.</p>

<p><div class=stopthink>
<b>Stop and think:</b>
What is wrong with this partial definition of <code>remove</code>?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>The problematic right-hand-side <code>(cons (car ls) ,B)</code> always constructs a pair containing the <code>car</code> of <code>ls</code> as the first element, even if the <code>car</code> contains the symbol we wish to remove.  In other words, there is never a recursive call on the <code>car</code> of <code>ls</code>.  If we look at the list passed to <code>remove</code> in the failing test case, we notice that its first element is itself a list containing the item we'd like to remove.  If the first element of <code>ls</code> is a list, we need to process it before including it in our result.  Adding a \mbox{\schemeresult|[(pair? (car ls)) ...]|} clause after the <code>[(null? ls) ...]</code> clause allows our test to be satisfied.</p>

<p>The debugging steps in this section are tedious to use by hand, but they could provide rich interactive feedback if automatically executed by an interactive development environment. It is interesting that we're able to refute programs without needing the support of a type system (though it is possible to combine a type inferencer, written as a relation, with the interpreter).</p>

<h2><a id="proof-checker"></a>A tiny theorem prover</h2>

<p>Here's a tiny proof-checker for propositional logic, written in Racket:</p>

<div class="live norun" id="proof-1">
(define proof?
  (lambda (proof)
    (match proof
      [`(,A ,assms assumption ())
       (member? A assms)]
      [`(,B ,assms modus-ponens (((,A => ,B) ,assms ,r1 ,ants1)
                                 (,A ,assms ,r2 ,ants2)))
       (and (proof? `((,A => ,B) ,assms ,r1 ,ants1))
            (proof? `(,A ,assms ,r2 ,ants2)))]
      [`((,A => ,B) ,assms conditional ((,B (,A . ,assms) ,rule ,ants)))
       (proof? `(,B (,A . ,assms) ,rule ,ants))])))
</div>

<p>A proof is represented as a list <code>(conclusion assumptions rule-name sub-proofs)</code> where:</p>
<ul>
 <li> <code>conclusion</code> is a miniKanren term;</li>
 <li> <code>assumptions</code> is a list of terms;</li>
 <li> <code>rule-name</code> is a symbol;</li>
 <li> <code>sub-proofs</code> is a list of zero or more proofs.</li>
</ul>

<p>This proof-checker has only three rules: assumptions, such as the proposition <code>A</code> or the implication <code>A => B</code>;
<em>modus ponens</em>, which derives <code>B</code> from <code>A</code> and <code>A => B</code>; and conditional proof, which derives <code>A => B</code> if we can derive <code>B</code> after assuming <code>A</code>.

For example, we can check this proof that <code>C</code> holds, assuming <code>A</code>, <code>A => B</code>, and <code>B => C</code>:</p>

<div class="live norun" id="ex-proof-1" data-lib="proof-1">
(proof? '(C (A (A => B) (B => C)) modus-ponens
            (((B => C) (A (A => B) (B => C)) assumption ())
             (B (A (A => B) (B => C)) modus-ponens
                (((A => B) (A (A => B) (B => C)) assumption ())
                 (A (A (A => B) (B => C)) assumption ()))))))
</div>

<p><div class=challenge>
<b>Challenge 6.</b>
Write a tiny theorem prover for the logic of the proof checker, <code>proof?</code>.
</div></p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 6?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>How might we write our tiny prover? A simple (though inefficient) algorithm might use a goal-directed, breadth-first search, which is complete over infinite trees. But miniKanren <em>already</em> implements a complete, goal directed search! What happens if we just run the proof checker in the relational interpreter we've used for the previous challenges?</p>

<p>Just as we treated the function <code>append</code> as a relation by running it inside the relational interpreter, we can treat the <code>proof?</code> function as a relation that connects assumptions, proofs, and conclusions. Here we query the <code>proof?</code> function to generate proofs of a theorem, given a set of assumptions:</p>

<div class="live hidden" id="evalo-optimized">
(load "evalo-optimized.scm")
(set! allow-incomplete-search? #t)
</div>

<div class="live" id="run-prf-1" data-lib="evalo-optimized">
(run 1 (prf)
  (fresh (body)
    ;; prove C holds, given A, A => B, B => C
    (== prf `(C (A (A => B) (B => C)) . ,body))
    (evalo
      `(letrec ([member?
                 (lambda (x ls)
                   (cond
                     ((null? ls) #f)
                     ((equal? (car ls) x) #t)
                     (else (member? x (cdr ls)))))]
                [proof?
                 (lambda (proof)
                   (match proof
                     [`(,A ,assms assumption ()) (member? A assms)]
                     [`(,B ,assms modus-ponens
                           (((,A => ,B) ,assms ,r1 ,ants1)
                            (,A ,assms ,r2 ,ants2)))
                      (and (proof? `((,A => ,B) ,assms ,r1 ,ants1))
                           (proof? `(,A ,assms ,r2 ,ants2)))]
                     [`((,A => ,B) ,assms conditional
                        ((,B (,A . ,assms) ,rule ,ants)))
                      (proof? `(,B (,A . ,assms) ,rule ,ants))]))])
         (proof? ',prf))
      #t)))
</div>

<p>Sure enough, miniKanren finds the proof we checked previously.</p>

<p>By instantiating different parts of the query, we can use <code>proof?</code> in different ways. We can partially instantiate the proof and ask the query to fill in the missing parts, or provide assumptions and ask the query to search for all valid conclusions with corresponding proofs.  This method is powerful enough to prove interesting theorems, such as transitivity of implication:</p>

<div class="live" id="run-prf-2" data-lib="evalo-optimized">
(run 1 (prf)
  (fresh (body)
    ;; prove (A => B) => (B => C) => (A => C) holds absolutely
    (== prf `(((A => B) => ((B => C) => (A => C))) () . ,body))
    (evalo
      `(letrec ([member?
                 (lambda (x ls)
                   (cond
                     ((null? ls) #f)
                     ((equal? (car ls) x) #t)
                     (else (member? x (cdr ls)))))]
                [proof?
                 (lambda (proof)
                   (match proof
                     [`(,A ,assms assumption ()) (member? A assms)]
                     [`(,B ,assms modus-ponens
                           (((,A => ,B) ,assms ,r1 ,ants1)
                            (,A ,assms ,r2 ,ants2)))
                      (and (proof? `((,A => ,B) ,assms ,r1 ,ants1))
                           (proof? `(,A ,assms ,r2 ,ants2)))]
                     [`((,A => ,B) ,assms conditional
                        ((,B (,A . ,assms) ,rule ,ants)))
                      (proof? `(,B (,A . ,assms) ,rule ,ants))]))])
         (proof? ',prf))
      #t)))
</div>

<p>We can also prove commutativity of conjunction where conjunction is encoded with implication.</p>

<h2><a id="scheme-in-scheme"></a>Quines, revisited</h2>

<p><div class=challenge>
<b>Challenge 7.</b>
Generate a quine that uses <code>quasiquote</code> instead of <code>list</code> or <code>cons</code>.
</div></p>


<p>The quines using <code>list</code> and <code>cons</code> generated in section <a href="#quines">2</a> are a little verbose.

Surely a quine can be more concise! Perhaps a quine could use <code>quasiquote</code> to construct the expression.

Sadly, our <code>evalo</code> relational interpreter doesn't include the <code>quasiquote</code> form.

We could extend the interpreter to add it, but is there another way?</p>

<p><div class=stopthink>
<b>Stop and think:</b>
How would you solve Challenge 7 without modifying the relational interpreter?
<div style="text-align:center;"><img width=40 src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/240px-Vienna_Convention_road_sign_B2a.svg.png"></img></div>
</div></p>

<p>Unlike <code>append</code>, <code>quasiquote</code> can't be implemented as a function, since it does not directly evaluate its argument, but rather interprets its argument to find <code>unquote</code> forms. Thus we can't simply define <code>quasiquote</code> in the interpreter with <code>letrec</code>.

We need to go more meta!  We'll use a meta-circular evaluator running <em>inside</em> the relational interpreter.</p>

<p>Let's write an interpreter for a small subset of Racket that includes <code>quasiquote</code>, in the subset of Racket supported by the relational interpreter. Our query asserts that applying the nested interpreter to the quoted s-expression of the quine should return that same s-expression.</p>

<p class="footnote">The unfortunate representation of the pattern for matching unquote expressions results from an oddity of Racket's quasiquotation support. In other Scheme implementations that line can be written [`(,`unquote ,exp) (eval exp)].</p>

<div class="live" id="ss-evalo-1" data-lib="evalo-standard">
(run 1 (q)
  (evalo
    `(letrec ([eval-quasi
               (lambda (q eval)
                 (match q
                   [(? symbol? x) x]
                   [`() '()]
                   [`(,,'`unquote ,exp) (eval exp)]
                   [`(quasiquote ,datum) ('error)]
                   [`(,a . ,d)
                    (cons (eval-quasi a eval)
                          (eval-quasi d eval))]))])
       (letrec ([eval-expr
                 (lambda (expr env)
                   (match expr
                     [`(quote ,datum) datum]
                     [`(lambda (,(? symbol? x)) ,body)
                      (lambda (a)
                        (eval-expr body (lambda (y)
                                          (if (equal? x y)
                                              a
                                              (env y)))))]
                     [(? symbol? x) (env x)]
                     [`(quasiquote ,datum)
                      (eval-quasi
                       datum
                       (lambda (exp) (eval-expr exp env)))]
                     [`(,rator ,rand)
                      ((eval-expr rator env)
                       (eval-expr rand env))]))])
         (eval-expr ',q
                    'initial-env)))
    q))
</div>

<p>To keep the meta-circular evaluator concise, we don't implement nested quasiquotation.

Instead, whenever the meta-circular evaluator encounters a nested <code>quasiquote</code> it produces an error by illegally attempting to call a symbol.

The outer, relational interpreter handles such an error as failure, so the combination of interpreters won't generate programs using nested quasiquotation.

We use the same technique to fail upon variable lookup in the empty environment, which we represent with the symbol <code>initial-env</code>.</p>

<p>A nested <code>letrec</code> is necessary because our standard version of <code>evalo</code> does not support mutually-recursive definitions, though the optimized <code>evalo</code> used earlier does support mutual recursion.</p>

<p><div class="insight">
<b>Insight:</b>
The outer, relational interpreter must use a first-order representation of environments and closures, as miniKanren only supports first-order terms. However, our Racket-in-Racket can use higher order representations thanks to its meta-circular use of that outer implementation. Environments are represented as functions that accept a symbol and return the value to which it is bound.  When extending an environment, we wrap it in a new function that first checks a variable against the new binding.  If the variable doesn't match, the new function delegates to the original environment by calling the function representing it.
</div></p>

<p>The meta-circular evaluator uses pattern matching to recognize each form of expression. In the relational setting it's even more important than usual to specify programs unambiguously.  Consider what might happen if rather than using <code>match</code>, we were to use this conditional expression to recognize the syntax for a <code>lambda</code> expression:</p>

<div class="live norun" id="ss-ex-1">
;; pattern used with match
`(lambda (fake-unquote (? symbol? x)) fake-unquote body)

;; solution with conditional expression
(and (equal? 'lambda (car expr))
     (pair? (cadr expr))
     (symbol? (caadr expr))
     (pair? (cddr expr)))
</div>

<p>When evaluating an instantiated expression with well-formed syntax, this condition should work. But when generating expressions, miniKanren can invent any expression that satisfies the condition. It might generate the identity function like this:</p>
<div class="live norun" id="ss-res-1">
(lambda (x . _.0) x . _.1)</div>
<p>where <code>_.0</code> and <code>_.1</code> indicate that any term whatsoever may appear in those positions.  Although the values in those positions don't affect the behavior of the expression in this evaluator, they both have to be the empty list in order for this function to behave the way we expect in Racket.</p>

<p>To ensure the expression assumes the desired syntax, the condition would need two more checks to fully specify the form: <code>(null? (cdadr expr))</code> and <code>(null? (cdddr expr))</code>. In contrast, the natural way of writing the evaluator with <code>match</code> fully specifies the format.</p>

<p>Our <code>quasiquote</code> quine-generating query returns the answer:</p>
<div class="live norun" id="ss-res-quine-1">
((((lambda (_.0) `(,_.0 ',_.0))
   '(lambda (_.0) `(,_.0 ',_.0)))
  (=/= ((_.0 closure)) ((_.0 prim))) (sym _.0)))
</div>
<p>Finding quines through the meta-circular evaluator is much slower than the approach we used in section <a href="#quines">2</a>&mdash;this query takes 5 minutes with our current hardware&mdash;but it allows us to generate programs using a new language form without modifying our relational interpreter.</p>

<h2><a id="conclusion"></a>Conclusion</h2>

<p>While solving these programming challenges we've shown that a relational interpreter can be used to solve myriad problems: example-based synthesis of recursive programs; refutation and bug-finding for incomplete programs; and generating program inputs with desired properties, using both a single interpreter and multiple interpreters with different semantics. Our success in solving the most difficult of these challenges&mdash;such as synthesis of recursive programs&mdash;is due to optimizations that use convenient properties of purely functional programming languages. The freedom to re-order evaluation, thanks to lack of side effects, is particularly important.</p>

<p>We also found that relational interpreters can confer relational capabilities on higher-order functional languages, even through multiple levels of interpretation.

This pearl is a concrete demonstration that a functional program can have more (and surprising!) behaviors than just that for which it was originally written.

In some sense every experienced functional programmer knows this to be true&mdash;for example, we write semantics as relations.

The relational interpreter approach provides a technique for exercising the fully general relational meaning of a functional program.</p>

<h2>Acknowledgments</h2>

<p>This material is partially based on research sponsored by
<a href="https://dx.doi.org/10.13039/100000185">DARPA</a> under agreement number AFRL FA8750-15-2-0092
and by <a href="https://dx.doi.org/10.13039/100000001">NSF</a> under CAREER grant 1350344. The views
expressed are those of the authors and do not reflect the
official policy or position of the Department of Defense or
the U.S. Government. The U.S. Government is authorized to
reproduce and distribute reprints for Governmental purposes
notwithstanding any copyright notation thereon.</p>

<p>Stuart Halloway pointed out that the relational interpreter should be able to generate quines; thank you, Stuart!
We thank Larry Moss and the members of the Indiana University logic seminar for their encouragement, and for challenging us to generate twines and thrines.
Eric Holk and Dan Friedman worked with co-author Byrd on quine generation in miniKanren, which led to a paper (<a href="http://webyrd.net/quines/quines.pdf">PDF</a>) from which Challenge 2 was taken.</p>

<p>We thank Dan Friedman, Nada Amin, Jason Hemann, Rob Zinkov, Tom Gilray, Lisa Zhang, Jon Smock, Dann Toliver, Annie Cherkaev, Guannan Wei, Dmitri Boulytchev, Evan Donahue, Steve Gilardi, and the anonymous reviewers for their many helpful comments.</p>

{% endblock %}
